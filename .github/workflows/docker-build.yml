name: docker-build

on:
  workflow_call:
    inputs:
      registry:
        type: string
        default: "ghcr"

      registry-type:
        type: string
        default: "private"

      ghcr-owner:
        type: string
        default: ""

      repository-name:
        type: string
        required: true

      docker-tag:
        type: string
        default: "latest"

      docker-architecture:
        type: string
        default: "linux/amd64"

      build-context:
        type: string
        default: "."

      dockerfile-path:
        type: string
        default: "Dockerfile"

      clone-source:
        type: boolean
        default: false

      source-repo:
        type: string
        default: ""

      source-ref:
        type: string
        default: "main"

      dockerfile-mode:
        type: string
        default: "auto"

      fallback-dockerfile:
        type: string
        default: ""

      linter-fail:
        type: string
        default: "false"

      linter-verbose:
        type: boolean
        default: false

      linter-format:
        type: string
        default: "tty"

      node-version:
        type: string
        default: "20"

      aws-access-keys:
        type: boolean
        default: false

      aws-access-role:
        type: boolean
        default: false

    secrets:
      DOCKERHUB_USERNAME:
        required: false
      DOCKERHUB_TOKEN:
        required: false
      GITLAB_USERNAME:
        required: false
      GITLAB_PASSWORD:
        required: false
      AWS_ACCESS_KEY_ID:
        required: false
      AWS_SECRET_ACCESS_KEY:
        required: false
      AWS_ROLE_ARN:
        required: false
      AWS_ROLE_NAME:
        required: false
      REGION:
        required: false

permissions:
  contents: read
  packages: write

jobs:
  docker:
    runs-on: ubuntu-latest

    outputs:
      image_ref: ${{ steps.build.outputs.image_ref }}
      resolved_dockerfile: ${{ steps.resolve.outputs.dockerfile }}
      resolved_context: ${{ steps.resolve.outputs.context }}

    steps:
      - name: Checkout caller repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Clone source repository
        if: ${{ inputs.clone-source }}
        run: |
          set -euo pipefail
          if [ -z "${{ inputs.source-repo }}" ]; then
            echo "source-repo is required when clone-source=true"
            exit 1
          fi
          rm -rf src
          git clone "https://github.com/${{ inputs.source-repo }}.git" src
          cd src
          git checkout "${{ inputs.source-ref }}"

      - name: Resolve build context + dockerfile
        id: resolve
        run: |
          set -euo pipefail

          WORKDIR="."
          [ "${{ inputs.clone-source }}" = "true" ] && WORKDIR="src"

          # Normalize dockerfile-path (avoid null/empty)
          DF_IN="${{ inputs.dockerfile-path }}"
          if [ -z "${DF_IN}" ] || [ "${DF_IN}" = "null" ]; then
            DF_IN="Dockerfile"
          fi

          if [ -d "${WORKDIR}/${DF_IN}" ]; then
            DF_PATH="${WORKDIR}/${DF_IN}/Dockerfile"
          else
            DF_PATH="${WORKDIR}/${DF_IN}"
          fi

          CONTEXT_IN="${{ inputs.build-context }}"
          if [ -z "${CONTEXT_IN}" ] || [ "${CONTEXT_IN}" = "null" ]; then
            CONTEXT_IN="."
          fi
          CONTEXT_PATH="${WORKDIR}/${CONTEXT_IN}"

          SOURCE_EXISTS=false
          [ -f "$DF_PATH" ] && SOURCE_EXISTS=true

          MODE="${{ inputs.dockerfile-mode }}"
          [ -z "$MODE" ] && MODE="auto"
          [ "$MODE" = "null" ] && MODE="auto"

          FALLBACK="${{ inputs.fallback-dockerfile }}"

          if [ "$MODE" = "source" ] && [ "$SOURCE_EXISTS" != true ]; then
            echo "dockerfile-mode=source but Dockerfile not found at ${DF_PATH}"
            exit 1
          fi

          if [ "$MODE" = "fallback" ]; then
            if [ -z "$FALLBACK" ] || [ "$FALLBACK" = "null" ] || [ ! -f "$FALLBACK" ]; then
              echo "dockerfile-mode=fallback but fallback-dockerfile not found: ${FALLBACK}"
              exit 1
            fi
            DF_PATH="$FALLBACK"
          fi

          if [ "$MODE" = "auto" ] && [ "$SOURCE_EXISTS" != true ]; then
            if [ -z "$FALLBACK" ] || [ "$FALLBACK" = "null" ] || [ ! -f "$FALLBACK" ]; then
              echo "dockerfile-mode=auto but source Dockerfile missing and fallback-dockerfile not provided"
              exit 1
            fi
            DF_PATH="$FALLBACK"
          fi

          echo "context=$CONTEXT_PATH" >> "$GITHUB_OUTPUT"
          echo "dockerfile=$DF_PATH" >> "$GITHUB_OUTPUT"
          echo "Resolved context: $CONTEXT_PATH"
          echo "Resolved dockerfile: $DF_PATH"

      - name: Lint Dockerfile
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: ${{ steps.resolve.outputs.dockerfile }}
          no-fail: ${{ inputs.linter-fail }}
          verbose: ${{ inputs.linter-verbose }}
          format: ${{ inputs.linter-format }}

      - name: Set registry login variables
        id: registry
        run: |
          set -euo pipefail
          if [ "${{ inputs.registry }}" = "dockerhub" ]; then
            echo "registry=docker.io" >> $GITHUB_OUTPUT
            echo "username=${{ secrets.DOCKERHUB_USERNAME }}" >> $GITHUB_OUTPUT
            echo "password=${{ secrets.DOCKERHUB_TOKEN }}" >> $GITHUB_OUTPUT
          elif [ "${{ inputs.registry }}" = "ghcr" ]; then
            echo "registry=ghcr.io" >> $GITHUB_OUTPUT
            echo "username=${{ github.actor }}" >> $GITHUB_OUTPUT
            echo "password=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_OUTPUT
          elif [ "${{ inputs.registry }}" = "gitlab" ]; then
            echo "registry=registry.gitlab.com" >> $GITHUB_OUTPUT
            echo "username=${{ secrets.GITLAB_USERNAME }}" >> $GITHUB_OUTPUT
            echo "password=${{ secrets.GITLAB_PASSWORD }}" >> $GITHUB_OUTPUT
          else
            echo "Unsupported registry: ${{ inputs.registry }}"
            exit 1
          fi

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to registry
        uses: docker/login-action@v3
        if: ${{ inputs.registry != 'ecr' }}
        with:
          registry: ${{ steps.registry.outputs.registry }}
          username: ${{ steps.registry.outputs.username }}
          password: ${{ steps.registry.outputs.password }}

      - name: Build & push image
        id: build
        run: |
          set -euo pipefail

          TAG="${{ inputs.docker-tag }}"
          NAME="${{ inputs.repository-name }}"
          REG="${{ inputs.registry }}"

          if [ "$REG" = "ghcr" ]; then
            OWNER="${{ inputs.ghcr-owner }}"
            [ -z "$OWNER" ] && OWNER="${{ github.repository_owner }}"
            IMAGE="ghcr.io/${OWNER}/${NAME}:${TAG}"
          elif [ "$REG" = "dockerhub" ]; then
            IMAGE="${{ steps.registry.outputs.username }}/${NAME}:${TAG}"
          elif [ "$REG" = "gitlab" ]; then
            IMAGE="${{ steps.registry.outputs.username }}/${NAME}:${TAG}"
          else
            echo "Unsupported registry: $REG"
            exit 1
          fi

          echo "Building image: $IMAGE"
          echo "image_ref=$IMAGE" >> $GITHUB_OUTPUT

          docker buildx build \
            --platform "${{ inputs.docker-architecture }}" \
            --file "${{ steps.resolve.outputs.dockerfile }}" \
            --build-arg NODE_VERSION="${{ inputs.node-version }}" \
            --provenance=false \
            --push \
            -t "$IMAGE" \
            "${{ steps.resolve.outputs.context }}"
