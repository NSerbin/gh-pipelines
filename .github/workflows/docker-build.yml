name: docker-build

on:
  workflow_call:
    inputs:
      registry:
        description: "dockerhub | ghcr | gitlab | ecr"
        type: string
        default: "ghcr"

      registry-type:
        description: "ECR: private | public (reserved)"
        type: string
        default: "private"

      ghcr-owner:
        description: "Owner/org for GHCR images (e.g. nserbin). If empty, uses github.repository_owner"
        type: string
        default: ""

      repository-name:
        description: "Image name without registry/owner. Example: freedium-web"
        type: string
        required: true

      docker-tag:
        description: "Image tag"
        type: string
        default: "latest"

      docker-architecture:
        description: "Buildx platforms, ex: linux/amd64 or linux/amd64,linux/arm64"
        type: string
        default: "linux/amd64"

      build-context:
        description: "Build context path (relative to WORKDIR)"
        type: string
        default: "."

      dockerfile-path:
        description: "Dockerfile path OR directory (relative to WORKDIR). If dir, will use <dir>/Dockerfile"
        type: string
        default: "Dockerfile"

      clone-source:
        description: "true/false (string). If true, clone source-repo and build from it"
        type: string
        default: "false"

      source-repo:
        description: "ORG/REPO to clone when clone-source=true"
        type: string
        default: ""

      source-ref:
        description: "ref to checkout when clone-source=true"
        type: string
        default: "main"

      dockerfile-mode:
        description: "source | auto | fallback"
        type: string
        default: "source"

      fallback-dockerfile:
        description: "Fallback Dockerfile path (relative to current workspace)"
        type: string
        default: ""

      linter-no-fail:
        description: "true/false (string). If true, hadolint will NOT fail the workflow"
        type: string
        default: "true"

      linter-verbose:
        description: "true/false (string)"
        type: string
        default: "false"

      linter-format:
        description: "tty|json|..."
        type: string
        default: "tty"

      node-version:
        description: "NODE_VERSION build arg (only if Dockerfile uses it)"
        type: string
        default: "20"

      # ===== NEW: inject static assets in CI (wrapper build) =====
      inject-static:
        description: "true/false (string). If true, builds base image then wraps it adding static files"
        type: string
        default: "false"

      inject-static-source-dir:
        description: "Path (relative to WORKDIR root) containing static files to inject. Example: caddy/static"
        type: string
        default: ""

      inject-static-target-dir:
        description: "Where to stage the static folder name inside wrapper context. Default: static"
        type: string
        default: "static"

      inject-static-dest-path:
        description: "Destination path inside image. Default: /static"
        type: string
        default: "/static"

    secrets:
      DOCKERHUB_USERNAME:
        required: false
      DOCKERHUB_TOKEN:
        required: false
      GITLAB_USERNAME:
        required: false
      GITLAB_PASSWORD:
        required: false
      AWS_ACCESS_KEY_ID:
        required: false
      AWS_SECRET_ACCESS_KEY:
        required: false
      AWS_ROLE_ARN:
        required: false
      AWS_ROLE_NAME:
        required: false
      REGION:
        required: false

permissions:
  contents: read
  packages: write

jobs:
  docker:
    runs-on: ubuntu-latest
    outputs:
      image_ref: ${{ steps.out.outputs.image_ref }}
      resolved_dockerfile: ${{ steps.resolve.outputs.dockerfile }}
      resolved_context: ${{ steps.resolve.outputs.context }}

    steps:
      - name: Checkout caller repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Clone source repository
        if: ${{ inputs.clone-source == 'true' }}
        run: |
          set -euo pipefail
          if [ -z "${{ inputs.source-repo }}" ] || [ "${{ inputs.source-repo }}" = "null" ]; then
            echo "source-repo is required when clone-source=true"
            exit 1
          fi
          rm -rf src
          git clone "https://github.com/${{ inputs.source-repo }}.git" src
          cd src
          git checkout "${{ inputs.source-ref }}"
          git rev-parse --short HEAD

      - name: Resolve build context + dockerfile
        id: resolve
        run: |
          set -euo pipefail

          WORKDIR="."
          if [ "${{ inputs.clone-source }}" = "true" ]; then
            WORKDIR="src"
          fi

          DF_IN="${{ inputs.dockerfile-path }}"
          if [ -z "$DF_IN" ] || [ "$DF_IN" = "null" ]; then
            DF_IN="Dockerfile"
          fi

          if [ -d "${WORKDIR}/${DF_IN}" ]; then
            DF_PATH="${WORKDIR}/${DF_IN}/Dockerfile"
          else
            DF_PATH="${WORKDIR}/${DF_IN}"
          fi

          CONTEXT_IN="${{ inputs.build-context }}"
          if [ -z "$CONTEXT_IN" ] || [ "$CONTEXT_IN" = "null" ]; then
            CONTEXT_IN="."
          fi
          CONTEXT_PATH="${WORKDIR}/${CONTEXT_IN}"

          SOURCE_EXISTS="false"
          if [ -f "${DF_PATH}" ]; then
            SOURCE_EXISTS="true"
          fi

          MODE="${{ inputs.dockerfile-mode }}"
          FALLBACK="${{ inputs.fallback-dockerfile }}"

          if [ "$MODE" = "source" ] && [ "$SOURCE_EXISTS" != "true" ]; then
            echo "dockerfile-mode=source but Dockerfile not found at: ${DF_PATH}"
            exit 1
          fi

          if [ "$MODE" = "fallback" ]; then
            if [ -z "$FALLBACK" ] || [ "$FALLBACK" = "null" ] || [ ! -f "$FALLBACK" ]; then
              echo "dockerfile-mode=fallback but fallback-dockerfile not found: ${FALLBACK}"
              exit 1
            fi
            DF_PATH="$FALLBACK"
          fi

          if [ "$MODE" = "auto" ] && [ "$SOURCE_EXISTS" != "true" ]; then
            if [ -z "$FALLBACK" ] || [ "$FALLBACK" = "null" ] || [ ! -f "$FALLBACK" ]; then
              echo "dockerfile-mode=auto and source Dockerfile missing at ${DF_PATH} and fallback missing"
              exit 1
            fi
            DF_PATH="$FALLBACK"
          fi

          echo "context=${CONTEXT_PATH}" >> "$GITHUB_OUTPUT"
          echo "dockerfile=${DF_PATH}" >> "$GITHUB_OUTPUT"

          echo "Resolved context: ${CONTEXT_PATH}"
          echo "Resolved dockerfile: ${DF_PATH}"

      - name: Lint Dockerfile (hadolint)
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: ${{ steps.resolve.outputs.dockerfile }}
          no-fail: ${{ inputs.linter-no-fail }}
          verbose: ${{ inputs.linter-verbose }}
          format: ${{ inputs.linter-format }}

      - name: Set registry login variables
        id: reg
        run: |
          set -euo pipefail
          if [ "${{ inputs.registry }}" = "dockerhub" ]; then
            echo "registry=docker.io" >> $GITHUB_OUTPUT
            echo "username=${{ secrets.DOCKERHUB_USERNAME }}" >> $GITHUB_OUTPUT
            echo "password=${{ secrets.DOCKERHUB_TOKEN }}" >> $GITHUB_OUTPUT
          elif [ "${{ inputs.registry }}" = "ghcr" ]; then
            echo "registry=ghcr.io" >> $GITHUB_OUTPUT
            echo "username=${{ github.actor }}" >> $GITHUB_OUTPUT
            echo "password=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_OUTPUT
          elif [ "${{ inputs.registry }}" = "gitlab" ]; then
            echo "registry=registry.gitlab.com" >> $GITHUB_OUTPUT
            echo "username=${{ secrets.GITLAB_USERNAME }}" >> $GITHUB_OUTPUT
            echo "password=${{ secrets.GITLAB_PASSWORD }}" >> $GITHUB_OUTPUT
          else
            echo "Unknown registry: ${{ inputs.registry }}"
            exit 1
          fi

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to registry
        uses: docker/login-action@v3
        with:
          registry: ${{ steps.reg.outputs.registry }}
          username: ${{ steps.reg.outputs.username }}
          password: ${{ steps.reg.outputs.password }}

      - name: Compute image refs
        id: img
        run: |
          set -euo pipefail

          TAG="${{ inputs.docker-tag }}"
          NAME="${{ inputs.repository-name }}"
          REG="${{ inputs.registry }}"

          if [ "$REG" = "ghcr" ]; then
            OWNER="${{ inputs.ghcr-owner }}"
            if [ -z "$OWNER" ] || [ "$OWNER" = "null" ]; then
              OWNER="${{ github.repository_owner }}"
            fi
            IMAGE_FINAL="ghcr.io/${OWNER}/${NAME}:${TAG}"
            IMAGE_BASE="ghcr.io/${OWNER}/${NAME}:${TAG}-base"
          elif [ "$REG" = "dockerhub" ]; then
            IMAGE_FINAL="${{ steps.reg.outputs.username }}/${NAME}:${TAG}"
            IMAGE_BASE="${{ steps.reg.outputs.username }}/${NAME}:${TAG}-base"
          elif [ "$REG" = "gitlab" ]; then
            IMAGE_FINAL="${{ steps.reg.outputs.username }}/${NAME}:${TAG}"
            IMAGE_BASE="${{ steps.reg.outputs.username }}/${NAME}:${TAG}-base"
          else
            echo "Unsupported registry: $REG"
            exit 1
          fi

          echo "image_final=${IMAGE_FINAL}" >> "$GITHUB_OUTPUT"
          echo "image_base=${IMAGE_BASE}" >> "$GITHUB_OUTPUT"

          echo "Final image: ${IMAGE_FINAL}"
          echo "Base  image: ${IMAGE_BASE}"

      - name: Build & push image (normal)
        id: build_normal
        if: ${{ inputs.inject-static != 'true' }}
        run: |
          set -euo pipefail

          IMAGE="${{ steps.img.outputs.image_final }}"

          echo "Building image: $IMAGE"

          docker buildx build \
            --platform "${{ inputs.docker-architecture }}" \
            --file "${{ steps.resolve.outputs.dockerfile }}" \
            --build-arg NODE_VERSION="${{ inputs.node-version }}" \
            --provenance=false \
            --push \
            -t "$IMAGE" \
            "${{ steps.resolve.outputs.context }}"

      - name: Build & push BASE image (inject-static)
        id: build_base
        if: ${{ inputs.inject-static == 'true' }}
        run: |
          set -euo pipefail

          IMAGE_BASE="${{ steps.img.outputs.image_base }}"

          echo "Building BASE image: $IMAGE_BASE"

          docker buildx build \
            --platform "${{ inputs.docker-architecture }}" \
            --file "${{ steps.resolve.outputs.dockerfile }}" \
            --build-arg NODE_VERSION="${{ inputs.node-version }}" \
            --provenance=false \
            --push \
            -t "$IMAGE_BASE" \
            "${{ steps.resolve.outputs.context }}"

      - name: Build & push FINAL image with static injected (wrapper)
        id: build_wrapper
        if: ${{ inputs.inject-static == 'true' }}
        run: |
          set -euo pipefail

          WORKDIR="."
          if [ "${{ inputs.clone-source }}" = "true" ]; then
            WORKDIR="src"
          fi

          SRC_DIR="${{ inputs.inject-static-source-dir }}"
          if [ -z "$SRC_DIR" ] || [ "$SRC_DIR" = "null" ]; then
            echo "inject-static-source-dir is required when inject-static=true"
            exit 1
          fi

          FULL_SRC="${WORKDIR}/${SRC_DIR}"
          if [ ! -d "$FULL_SRC" ]; then
            echo "inject-static-source-dir not found: ${FULL_SRC}"
            exit 1
          fi

          STAGE=".ci-wrapper"
          rm -rf "$STAGE"
          mkdir -p "$STAGE/${{ inputs.inject-static-target-dir }}"

          echo "Copying static from: ${FULL_SRC} -> ${STAGE}/${{ inputs.inject-static-target-dir }}/"
          cp -a "${FULL_SRC}/." "$STAGE/${{ inputs.inject-static-target-dir }}/"

          IMAGE_BASE="${{ steps.img.outputs.image_base }}"
          IMAGE_FINAL="${{ steps.img.outputs.image_final }}"
          DEST="${{ inputs.inject-static-dest-path }}"

          cat > "$STAGE/Dockerfile" <<EOF
          FROM ${IMAGE_BASE}
          COPY ${{ inputs.inject-static-target-dir }}/ ${DEST}/
          EOF

          echo "Building FINAL image (wrapper): ${IMAGE_FINAL}"
          docker buildx build \
            --platform "${{ inputs.docker-architecture }}" \
            --file "$STAGE/Dockerfile" \
            --provenance=false \
            --push \
            -t "${IMAGE_FINAL}" \
            "$STAGE"

      - name: Set output image ref
        id: out
        run: |
          set -euo pipefail
          echo "image_ref=${{ steps.img.outputs.image_final }}" >> "$GITHUB_OUTPUT"
