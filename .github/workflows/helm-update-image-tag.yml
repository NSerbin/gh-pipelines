name: Reusable - Helm Update Image Tag (multi updates)

on:
  workflow_call:
    inputs:
      charts_repo:
        description: "Repo destino con charts (ORG/REPO)"
        type: string
        required: true
      charts_ref:
        description: "Branch a modificar"
        type: string
        default: "main"
      chart_path:
        description: "Path al chart dentro del repo (ej: charts/freedium)"
        type: string
        required: true
      values_file:
        description: "Values file relativo al chart (ej: values.yaml)"
        type: string
        default: "values.yaml"

      image_tag:
        description: "Nuevo tag (ej: sha-xxxxxxx)"
        type: string
        required: true

      updates_json:
        description: |
          JSON array con updates:
          [
            {"path":".image.tag","valueFrom":"tag"},
            {"path":".caddy.image.tag","valueFrom":"tag"},
            {"path":".image.repository","value":"ghcr.io/..."}
          ]
        type: string
        required: true

      update_app_version:
        description: "Si true, setea Chart.yaml appVersion = image_tag"
        type: boolean
        default: false

      commit_message:
        description: "Mensaje base del commit"
        type: string
        default: "chore(helm): bump images"

    secrets:
      SYNC_APP_ID:
        required: true
      SYNC_APP_PRIVATE_KEY:
        required: true

jobs:
  update:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Mint GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.SYNC_APP_ID }}
          private-key: ${{ secrets.SYNC_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      - name: Checkout charts repo
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.charts_repo }}
          ref: ${{ inputs.charts_ref }}
          token: ${{ steps.app-token.outputs.token }}
          fetch-depth: 0

      - name: Install yq (pinned)
        run: |
          set -euo pipefail
          YQ_VERSION="v4.45.4"
          sudo wget -qO /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64"
          sudo chmod +x /usr/local/bin/yq
          yq --version

      - name: Apply updates_json into values.yaml
        env:
          CHART_PATH: ${{ inputs.chart_path }}
          VALUES_FILE: ${{ inputs.values_file }}
          IMAGE_TAG: ${{ inputs.image_tag }}
          UPDATES_JSON: ${{ inputs.updates_json }}
        run: |
          set -euo pipefail

          VALUES_PATH="${CHART_PATH}/${VALUES_FILE}"
          test -f "$VALUES_PATH" || { echo "Values file not found: $VALUES_PATH"; exit 1; }

          python - <<'PY'
          import json, os, subprocess, sys

          values_path = os.environ["VALUES_PATH"] if "VALUES_PATH" in os.environ else None
          if not values_path:
            # fallback (we set it below)
            pass
          PY

          # Export para python (evita KeyError)
          export VALUES_PATH="${VALUES_PATH}"

          python - <<'PY'
          import json, os, subprocess, sys

          updates_raw = os.environ.get("UPDATES_JSON", "[]").strip()
          image_tag = os.environ.get("IMAGE_TAG", "").strip()
          values_path = os.environ["VALUES_PATH"]

          try:
            updates = json.loads(updates_raw)
          except Exception as e:
            print("updates_json is not valid JSON:", e)
            print("RAW:", updates_raw)
            sys.exit(1)

          if not isinstance(updates, list):
            print("updates_json must be a JSON array")
            sys.exit(1)

          def yq_set(path, value):
            env = os.environ.copy()
            env["VAL"] = str(value)
            cmd = ["yq", "-i", f"{path} = strenv(VAL)", values_path]
            r = subprocess.run(cmd, text=True, capture_output=True, env=env)
            if r.returncode != 0:
              print("yq failed:", " ".join(cmd))
              print(r.stdout)
              print(r.stderr)
              sys.exit(r.returncode)

          for u in updates:
            if not isinstance(u, dict) or "path" not in u:
              print("Invalid update entry:", u)
              sys.exit(1)

            path = u["path"]
            if "valueFrom" in u and u["valueFrom"] == "tag":
              val = image_tag
            else:
              val = u.get("value", "")

            yq_set(path, val)

          print(f"Applied {len(updates)} update(s) to {values_path}")
          PY

      - name: Update Chart.yaml appVersion (optional)
        if: ${{ inputs.update_app_version }}
        env:
          CHART_PATH: ${{ inputs.chart_path }}
          IMAGE_TAG: ${{ inputs.image_tag }}
        run: |
          set -euo pipefail
          CHART="${CHART_PATH}/Chart.yaml"
          test -f "$CHART" || { echo "Chart.yaml not found: $CHART"; exit 1; }
          yq -i '.appVersion = strenv(IMAGE_TAG)' "$CHART"

      - name: Commit & push if changed
        env:
          CHARTS_REF: ${{ inputs.charts_ref }}
          COMMIT_MESSAGE: ${{ inputs.commit_message }}
          IMAGE_TAG: ${{ inputs.image_tag }}
          CHART_PATH: ${{ inputs.chart_path }}
          VALUES_FILE: ${{ inputs.values_file }}
        run: |
          set -euo pipefail

          if [ -z "$(git status --porcelain)" ]; then
            echo "No changes to commit."
            exit 0
          fi

          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git add "${CHART_PATH}/${VALUES_FILE}" || true
          if [ -f "${CHART_PATH}/Chart.yaml" ]; then
            git add "${CHART_PATH}/Chart.yaml" || true
          fi

          git commit -m "${COMMIT_MESSAGE}: ${IMAGE_TAG}"
          git push origin "${CHARTS_REF}"
